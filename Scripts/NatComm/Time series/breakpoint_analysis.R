# Breakpoint estimation function. See comments for in-depth explanations of code flow and functionality.
# Inputs depend on outputs generated by differential analyses (e.g. da_bypeakset.R), time series calculation
# (i.e., time_series_modeling.R) and clustering (time_series_clustering.R)

bp_test <- function(adj.data = NULL, # batch-adjusted data. Can use adj.data data frame generated as a by-product of differential analyses
                    predicted = NULL, # time series-fitted data with cluster information. Can use object "peaks_ts.nonzero.clustered.sorted_*" from the output of kbins_peaks()
                    test.sex = c("f","m","b"), # which sex data set to use (female, male, or intersection)
                    age.vector = NULL, # Named numeric vector of ages of samples used for analysis; names correspond to sample IDs
                    sex.vector = NULL, # Named character vector of sexes (F,M, case-sensitive) of samples used for analysis; names correspond to sample IDs
                    winspan = 10:20, # Range of window sizes tested in moving-window analyses
                    mininterval = 10, # minimum number of years separating two breakpoints. Breakpoints occuring within this interval are averaged by age
                    p.thresh = 0.05, # P-value cutoff to regard a local minumum P-value as significant
                    range.thresh = 0.25, # threshhold on the proportion of maximum sum of  pvalue that is spanned between a minimum and the nearest maximum. Minima separated from maxima by quantities larger than this value are considered breakpoints
                    stepsize = 1, # step size used in moving window analysis
                    bwspan = seq(0.25,0.75,0.05) # range of bandwidths used in loess smoothing of P-value vectors from moving window analysis, per window span
) {
  
  require(reshape2)
  require(ggplot2)
  require(tibble)
  require(dplyr)
  
  # Output filename
  bpfname <- paste0("./narrowPeaks_trendy.breakpoints_",ifelse(test.sex=="b","common",ifelse(test.sex=="f","females","males")),".RData")
  
  # List of ages by sex, based on sex choice (f(emales), m(ales), or b(oth))
  testage.list <- if (test.sex=="b") {
    list(females=age.vector[sex.vector=="F"],
         males=sort(age.vector[sex.vector=="M"]))
  } else {
    setNames(list(age.vector[sex.vector==toupper(test.sex)]),ifelse(test.sex=="f","females","males"))
  }
  
  breakpoints_bysex <- lapply(testage.list, function(testage) {
    testsamps=names(testage)
    atac.clustered.data <- data.frame(atac.adj.data[,testsamps]) %>% 
      rownames_to_column("peakco") %>% 
      inner_join(predicted %>% select(peakco,Cluster),by="peakco") %>%
      select(peakco,Cluster,everything()) %>%
      split(.,f = .$Cluster) %>%
      lapply(.,function(X) data.frame(X,row.names = "peakco") %>% 
               select(-Cluster) %>% 
               apply(.,1,function(y) (y-mean(y))/sd(y)) %>% 
               t() %>% 
               data.frame(.) %>% 
               rownames_to_column("peakco") %>%
               mutate(Cluster=paste0("Cluster",X$Cluster[1])) %>%
               select(peakco,Cluster,everything()))
    nclust = length(atac.clustered.data)
    breakpoints_bycluster <- lapply(setNames(as.list(winspan),winspan), function(ws) {
      # Breakpoints are identified for each window span separately
      cat("Extracting breakpoints for winspan=",ws,"\n")
      offset=c(min(testage)+ws,max(testage)-ws)
      testage.offset <- seq(offset[1],offset[2],stepsize)
      lapply(atac.clustered.data, function(Z) {
        cat(Z$Cluster[1],"\n")
        pvalues <- do.call(rbind,mclapply(bwspan, function(bw) {
          # For a given window span, breakpoints result from the integration of smoother p-value time trends across
          # multiple smoothing bandwidths. These p-values estimate the magnitude of the difference between ages prior
          # and posterior to each age point (where window span defines the sampled age period, and therefore sample size
          # and statistical power of the test)
          cat("Bandwidth=",bw,"\n")
          x <- t(sapply(setNames(as.list(testage.offset),as.numeric(testage.offset)), function(x) {
            print(x)
            agelo <- x-ws
            samplo <- names(testage[testage>=agelo & testage<=x])
            agehi <- x+ws
            samphi <- names(testage[testage>=x & testage<=agehi])
            Y <- Z %>% 
              select(peakco,samplo) %>% 
              melt(.,id.vars="peakco",variable.name="sampid",value.name="score") %>% 
              mutate(win="low") %>% 
              rbind(Z %>% 
                      select(peakco,samphi) %>%
                      melt(.,id.vars="peakco",variable.name="sampid",value.name="score") %>% 
                      mutate(win="high")) %>%
              dcast(.,sampid+win~peakco,value.var="score")
            V <- prcomp(as.matrix(Y %>% select(-sampid,-win)),scale. = T) # Dimensionality reduction prior to adjacent-window comparison
            wintest <- summary(manova(V$x[,1:3] ~ win,data=Y))$stats[1,6] # Input first 3 PCs to MANOVA for between-window comparison
            
            # add sample sizes to interpret p values under the light of power to detect differences
            output <- c(p=wintest,n_lo=length(samplo),n_hi=length(samphi))
            return(output)
          })) %>% 
            data.frame(.,row.names = NULL,check.names = F) %>% 
            mutate(age=testage.offset)
          # P-value smoothing in preparation for detection of local minima
          y <- loess(data=x,formula = p ~ age,span=bw)
          z <- data.frame(age=y$x,observed_p=y$y,fitted_p=y$fitted,n_low=x$n_lo,n_high=x$n_hi,bandwidth=bw,winspan=ws)
          return(z)
        },mc.cores = 1))
        
        # Truncating resulting p-values to (0,1] interval
        pvalues <- pvalues %>%
          mutate(fitted_p=ifelse(fitted_p>1,1,
                                 ifelse(fitted_p<=0,min(.$fitted_p[.$fitted_p>0]),fitted_p)))
        
        # Detection of p-value maxima/minima is done on smnoothed p-values integrated by each evaluation age point
        # At each age, p-values calculated at all bandwidths for a given window span are integrated using Fisher's 
        # method, and the resulting values are smoothed again. Local minima and maxima are located in this function
        # using numerical differentiation. A parametric "significant" value is also calculated for each age point
        # by comparing the smoothed Fisher's P value to its null Chi-squared expectation.
        breakpoints = pvalues %>% 
          group_by(age) %>% 
          summarize(sum_fitted_p=-2*sum(log(fitted_p)), # Fisher's method for P-value combination
                    sum_observed_p=-2*sum(log(observed_p))) %>%
          ungroup() %>% 
          mutate(sum_refitted_p = loess(sum_fitted_p ~ age, data = data.frame(.),span = 0.25)$fitted) %>%
          mutate(isMinimum=age %in% .[c(which(c(diff(sign(diff(.$sum_refitted_p))),FALSE,FALSE)==2)+1,which(c(FALSE,diff(.$sum_refitted_p)<0) & age==max(.$age)),which(c(diff(.$sum_refitted_p)>0,FALSE) & age==min(.$age))),]$age,
                 isMaximum=age %in% .[c(which(c(diff(sign(diff(.$sum_refitted_p))),FALSE,FALSE)==-2)+1,which(c(diff(.$sum_refitted_p)<0,FALSE) & age==min(.$age)),which(c(FALSE,diff(.$sum_refitted_p)>0) & age==max(.$age))),]$age,
                 isSignificantP=pchisq(sum_fitted_p,df = length(bwspan))>=(1-p.thresh))
        if (!any(breakpoints$isMinimum)) {
          breakpoints <- breakpoints %>%
            mutate(isMinimum=(sum_refitted_p==min(.$sum_refitted_p)[1]))
        }
        if (!any(breakpoints$isMaximum)) {
          breakpoints <- breakpoints %>%
            mutate(isMaximum=(sum_refitted_p==max(.$sum_refitted_p)[1]))
        }
        
        # As a second "significance" criterion, for each minimum we find the distance to the nearest *previous (in time)* 
        # maximum: drops that exceed a pre-defined threshold (range.thresh) are considered significant as well
        MinMax <- list(Min=(breakpoints %>% filter(isMinimum))$age,Max=(breakpoints %>% filter(isMaximum))$age)
        MinMaxMx <- outer(seq(length(MinMax$Min)),
                          seq(length(MinMax$Max)),
                          Vectorize(function(i,j) abs(MinMax$Min[i]-MinMax$Max[j])))
        MinMaxMatch <- data.frame(age=MinMax$Min[apply(MinMaxMx,2,which.min)]) %>%
          inner_join(breakpoints %>% select(age,sum_refitted_p),by="age") %>%
          rename_(MinAge="age",min_sum_refitted_p="sum_refitted_p") %>%
          cbind(data.frame(age=MinMax$Max))
        
        # Finally, a breakpoint is defined for a specific window span for age points which satisfy the two significance
        # conditions calculated above
        breakpoints <- breakpoints %>% 
          left_join(MinMaxMatch,by="age") %>% 
          mutate(diffToMin=ifelse(!is.na(MinAge),(sum_refitted_p-min_sum_refitted_p)/max(.$sum_refitted_p),0)) %>% 
          mutate(isBreak=diffToMin>=range.thresh & isSignificantP)
        
        # Breakpoint post-processing:
        # Collapsing breakpoints that are too close (within ws years, i.e. whose difference is lower than the resolution of a test given window span)
        # Algorithm: sort breakpoints by age and work from the oldest collapsing any breakppoint within the restricting interval, 
        # keeping only the one with the lowest Pvalue
        breaks <- subset(breakpoints,isBreak)
        nBreaks = nrow(breaks)
        if (nBreaks>1) {
          mBreaks = 0
          while(nBreaks!=mBreaks) {
            mBreaks = nBreaks
            brlags <- cbind(breaks$age,lag(breaks$age))
            breaks <- subset(breaks,!age %in% brlags[last(which(abs(apply(brlags,1,diff))<ws)),]) %>%
              rbind(subset(breaks,age %in% brlags[last(which(abs(apply(brlags,1,diff))<ws)),]) %>% arrange(sum_observed_p) %>% slice_(1))
            nBreaks = nrow(breaks)
          }
        }
        breakpoints <- rbind(subset(breakpoints,!age %in% breaks$age) %>% mutate(isBreak=F),breaks) %>%
          arrange(age)
        return(list(pvalues=pvalues,breakpoints=breakpoints))
      })
    })
  })
  
  # Diagnostic plots: p value trajectories marking breakpoints, breakpoints with variation (error bars)
  allBreaks <- lapply(breakpoints_bysex,
                      function(X) {
                        nclust = length(X[[1]])
                        lapply(setNames(as.list(seq_len(nclust)),seq_len(nclust)),
                               function(k)
                                 lapply(lapply(X,
                                               function(S) lapply(S,`[[`,"breakpoints")),`[[`,k))
                      })
  
  allBreakpoints <- do.call(rbind,lapply(names(allBreaks),
                                         function(sx)
                                           do.call(rbind, lapply(names(allBreaks[[sx]]),
                                                                 function(k) do.call(rbind,lapply(names(allBreaks[[sx]][[k]]),
                                                                                                  function(s) allBreaks[[sx]][[k]][[s]] %>%
                                                                                                    filter(isBreak) %>%
                                                                                                    select(age,sum_refitted_p,isBreak) %>%
                                                                                                    mutate(sex=sx,cluster=k,winspan=s))))) %>%
                                           split(.,f=.$cluster) %>%
                                           lapply(., function(B) {
                                             X <- B %>% 
                                               group_by(winspan) %>% 
                                               mutate(n=n()) %>% 
                                               ungroup() %>%
                                               mutate(breakn=if (diff(range(.$age))<=mininterval) 1 else Mclust(.$age,G = max(.$n),modelNames = "E",verbose = F)$classification) %>%
                                               group_by(sex,breakn) %>%
                                               mutate(break.n=n()) %>%
                                               ungroup() %>%
                                               mutate(break.n=ifelse(is.na(breakn),breakn,break.n))
                                             while(any(X$break.n < round(length(globalenv()$winspan)/4))) { # a breakpoint should be supported by at least half of the winspans tested
                                               X <- X %>%
                                                 filter(break.n >= round(length(globalenv()$winspan)/4)) %>%
                                                 group_by(winspan) %>% 
                                                 mutate(n=n()) %>% 
                                                 ungroup() %>%
                                                 mutate(breakn=if (diff(range(.$age))<=mininterval) 1 else Mclust(.$age,G = max(.$n),modelNames = "E",verbose = F)$classification) %>%
                                                 group_by(sex,breakn) %>%
                                                 mutate(break.n=n()) %>%
                                                 ungroup() %>%
                                                 mutate(break.n=ifelse(is.na(breakn),breakn,break.n))
                                             }
                                             X %>%
                                               group_by(sex,breakn,cluster) %>%
                                               summarize(n_breaks=max(n),
                                                         break.n=n(),
                                                         break.mean_age=round(approxfun(sum_refitted_p,age)(mean(sum_refitted_p))),
                                                         break.median_age=round(approxfun(sum_refitted_p,age)(median(sum_refitted_p))),
                                                         p.mean=mean(sum_refitted_p),
                                                         p.median=median(sum_refitted_p),
                                                         p.max=max(sum_refitted_p),
                                                         p.sd=sd(sum_refitted_p),
                                                         break.min_age=min(age),
                                                         break.max_age=max(age),
                                                         break.q25_age=quantile(age,.25),
                                                         break.q75_age=quantile(age,.75)) %>% 
                                               ungroup()
                                           }) %>%
                                           do.call(rbind,.)
  ))
  
  plotAllBreaks <- ggplot(allBreakpoints %>% mutate(cluster=paste("Cluster",cluster)),aes(cluster,break.median_age,group=breakn)) +
    geom_point() +
    geom_errorbar(aes(ymin=break.min_age,ymax=break.max_age),width=0.25) +
    geom_text(aes(label=break.median_age),hjust=-1) +
    scale_color_brewer(type = "qual",palette=2,guide=F) +
    labs(x="",
         y="Age breakpoint estimates, yo median,min-max",
         title="Age breakpoint estimates for peak clusters",
         subtitle=paste("ATACseq data for",ifelse(test.sex=="f","females",ifelse(test.sex=="b","females and males","males")))) +
    facet_wrap(~sex,ncol=1) +
    theme_bw(base_size = 12) +
    theme(aspect.ratio = 1,strip.background = element_blank())
  plotAllBreaks
  
  plotBreakpoints <- do.call(rbind,lapply(names(allBreaks),
                                          function(sx)
                                            do.call(rbind, lapply(names(allBreaks[[sx]]),
                                                                  function(k) do.call(rbind,lapply(names(allBreaks[[sx]][[k]]),
                                                                                                   function(s) allBreaks[[sx]][[k]][[s]] %>%
                                                                                                     select(age,sum_refitted_p,isBreak) %>%
                                                                                                     mutate(sex=sx,cluster=k,winspan=s))))))) %>%
    group_by(sex,cluster,age) %>%
    summarize(median_refitted_p=median(sum_refitted_p),
              mean_refitted_p=mean(sum_refitted_p)) %>%
    ungroup() %>%
    left_join(allBreakpoints %>%
                mutate(age=break.median_age,age.min=break.min_age,age.max=break.max_age,isBreak=T) %>%
                select(sex,cluster,age,age.min,age.max,isBreak),
              by=c("sex","age","cluster")) %>%
    left_join(do.call(rbind,lapply(data.frame(.) %>% select(age,sex,cluster) %>% split(.,1:nrow(.)),function(x) {
      int_test <- apply(x$age-merge(allBreakpoints,x,by=c("sex","cluster"))[,c("break.min_age","break.max_age")],1,prod)<=0
      x$isBreakInterval <- ifelse(any(int_test),merge(allBreakpoints,x,by=c("sex","cluster"))[which(int_test),]$breakn,NA)
      return(x)})),
      by=c("age","cluster","sex")) %>%
    mutate(isBreak=!is.na(isBreak),
           isBreakInterval=ifelse(is.na(isBreakInterval),0,isBreakInterval)) %>% {
             ggplot(.,aes(age,mean_refitted_p,group=cluster,color=cluster,fill=cluster,shape=isBreak,size=isBreak)) +
               geom_line(size=0.75) +
               geom_line(data=data.frame(.) %>% filter(isBreakInterval>0),
                         aes(age,mean_refitted_p,group=paste0(isBreakInterval,cluster),color=cluster),size=3,alpha=0.5,inherit.aes = F) +
               geom_rect(aes(xmin=age.min,xmax=age.max,ymin=0,ymax=max(.$mean_refitted_p)*1.05),color=NA,alpha=0.1,na.rm = T,show.legend = F) +
               geom_point(alpha=0.5) +
               geom_text(data=data.frame(.) %>% filter(isBreak),aes(label=age),color="black",fontface="bold",size=4,vjust=2) +
               geom_hline(yintercept = 120) +
               geom_vline(data = data.frame(.) %>% filter(isBreak,sex=="females"),aes(xintercept = age,color=cluster),size=0.5,alpha=0.5) +
               geom_vline(data = data.frame(.) %>% filter(isBreak,sex=="males"),aes(xintercept = age,color=cluster),size=0.5,alpha=0.5) +
               scale_shape_manual(values = c("FALSE"=16,"TRUE"=25),guide=F) +
               scale_size_manual(values = c("FALSE"=1.5,"TRUE"=3),guide=F) +
               scale_color_manual(values = brewer.dark2(4),guide=guide_legend(override.aes = list(size=2))) +
               scale_fill_manual(values = brewer.dark2(4),guide=F) +
               labs(x="Age, yo",
                    y="mean P-value estimate, -log10 P",
                    title="Mean P-value estimates from sliding window test and predicted age break points",
                    subtitle=paste0("Window span=",paste(range(winspan),collapse = "-")," yo, step size=",stepsize,", sex: ",ifelse(test.sex=="f","females",ifelse(test.sex=="b","females and males","males")),", ATAC-seq")) +
               facet_wrap(~sex,ncol=1) +
               theme_minimal(base_size = 12) +
               theme(aspect.ratio = 0.33,axis.line.x = element_line(size=0.25),axis.line.y = element_line(size=0.25))
           }
  print(plotBreakpoints)
  
  savebp <- c("breakpoints_bysex",
              "allBreakpoints",
              "allBreaks",
              "testage.list",
              "winspan",
              "mininterval",
              "p.thresh",
              "range.thresh",
              "stepsize",
              "bwspan",
              "plotAllBreaks",
              "plotBreakpoints")
  save(list = savebp,file = bpfname)
}